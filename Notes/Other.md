1. 开始算法的编写之前，先对鲁棒性的代码进行考虑。
   
   1. 对方法输入值的可能情况进行全面的考虑
   
2. 考虑所有可能出现的情况！！！

3. 有时候要聪明点，不要在一些细枝末节的地方纠结半天，有些条件该自己给出的就自己给出即可

4. 学会用while加条件可以替代for循环

5. 对于代码鲁棒性的算法，不仅要考虑特殊值的情况，还要考虑使用数据结构自身的因素可能会有哪些问题导致代码崩溃的

6. 对于链表、树这样的结构，肯定是要先创建节点的结构的

7. 对于较难的问题，或者树这样的结构，先画图，再思考

8. 关于栈的问题，可以使用递归，递归本质上就是栈（后进先出）

9. 数组越界问题，先看看判断语句中条件是否对了，一般加个条件即可解决

10. 活用自增自减操作，让代码更简洁！！！

11. 只有一行的循环语句，将括号省略，看起来更简洁！！！

12. 关于n位的整数并且没有限定n的取值范围，或者输入任意大小的整数，那么，很有可能是大数问题
    1. 通常使用字符串，数组的方式来解决大数问题！！！
    2. 如果对象是一个整型数组，且是在后面才会发生大数溢出问题，那么可以是使用集合，将类型参数指定为`String`来表示这个整型数组
    
13. 关于指针的命名，加一个p作为前缀即可。如：pNode

14. 如果在流程中，下一步有多种情况可以走，并且只要一个走成功即为成功，则可以使用短路或（||）来实现

15. 写完代码后要考虑逻辑抽离/解耦/代码扩展性方面
    
    1. 假如你没有考虑这些，然后面试官又提出了一系列与题目类似的题目（都是需要改下部分代码即可），这时就要意识到这就到了考虑代码扩展性的时候——抽离逻辑为另外一个函数
    
16. 能使用位运算的地方就用位运算，前提是保证自己不出错，位运算效率要高于普通的四则运算
    1. 在判断条件中使用位运算，要用括号提高优先级，如：`if((count & 1) == 0)`
    2. 判断是否为偶数：`if((count & 1) == 0)`
    3. 除以2：`count >> 1`
    4. 乘以2：`count << 1`
    
17. 有时候条件的在代码中的位置顺序不同也会出问题！！！

18. 在使用`java`的`LinkedList`时，要弄清楚是作队列，还是作栈，还是做链表来使用的，分别调用的是不同的方法！！！

19. 比较复杂的题目，分步骤完成

20. 使用递归时，不要忘记了留一个递归出口！！！
    1. 递归时，如果上一层函数需要用到下一层函数的东西，**不可以**将函数多设置一个参数，然后下一层去改参数
       1. 因为`java`是**值传递**的
       2. 这时候我们可以在外面的类中设置一个变量，如果非要使用参数的方式的话，可以创建一个类将参数包装一下，或者使用数组来表示
    
21. ```
    递归从最大问题开始自上而下解决问题，有了重复的地方，我们可以从最小的子问题开始自下而上的解决问题，消除重复地方
    对于递归方式有大量重复的计算，我们这时候可以使用循环来代替
    ```

22. 所谓一个数m是一个数n的因子，就是指n能被m整数