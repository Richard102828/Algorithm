# Algorithm
记录算法实现代码《剑指offer》、心得体会等

* 下面的内容会一直更新，不光是《剑指offer》上面的算法，在力扣上面刷的也会在这里更新~

# 算法

标签（空格分隔）： 面试复习

------

记录典型算法、数据结构相关知识，重在解题思路的总结

[TOC]

- 剑指offer中没有再看的题目
  - 51
  - 3的变种
  - 41

## 数据结构

### 数组

- **基本知识**
  - 排序：正序：`Arrays.sort(tasksTimes);`
- **题目类型**
  - 找特殊的数字组合（如：`逆序对`）
  - 一个排好序的数组，找符合特定条件的数字序列（如：`和为s的数字`）
  - 数组中数字的次数，找符合条件的数字（如：`其它都出现两次，要找出现一次的两个数`、`其它都出现三次，找只出现一次的`、`数组中出现次数超过一半的数字`）
    - 关于次数的题目，题目要求了空间复杂度导致不能用哈希表的话，一般得使用位运算
  - 找最小的、最大的几个数（如：`最小的K个数`）
  - 数组中连续数字的题目（如：`连续子数组的最大和`）
  - 二维数组（如：`二维数组中的查找`、`顺时针打印矩阵`）
  - 重复数字（`数组中重复的数字`）
  - 合并数组
  - 其它
    - 存在比较的情况，可以使用双指针法
- **注意事项**
  - 使用集合 `ArrayList` 时，`toArray()`方法返回的数组是 `Object[]`类型的
  - 数组越界问题

### 字符串

- **基本知识**
  - 字符串的题，可以使用哈希表来保存字符的出现次数（哈希表中查找时间复杂度为O(1)，O(n)的额外的空间复杂度）
  - ASCII码表大小为：256个。因此，在不考虑中问、特殊字符的情况下：可以创建一个256长度大小的`int`数组，用于下标对应到字符上`times[str.charAt(i)]`（注意这里，字符会自动变为`int`型），来代替哈希表
  - 字符流：唯一的区别就是长度不是固定的，所以我们在面对这种题型的时候，就可以通过写一个类，然后提供`insert()`插入方法，来供外界从字符流中插入字符，然后在这个类中写方法对具体的问题进行解决
    - 对于具体的字符流是多少，我们是不用关心的
  - 要对源字符串进行修改的，可以用`StringBuilder`做参数。或者使用`char[] chars = str.toCharArray();`将字符串转为字符数组。返回一个字符串时，使用`return new String(chars)`从字符数组中构造字符串，并返回
- **题目类型**
  - 找某个字符出现的次数（如：`第一个只出现一次的字符`、`字符流中第一个只出现一次的字符`）
  - 对字符串现有的位置、字符状态进行改变（如：`翻转字符串`、`左旋转字符串`、`字符串的排列`）
  - 对字符串中的空格进行处理（如：`替换空格`）
  - 字符串与其它的类型的转换（如：`字符串转整数`）
- **注意事项**
  - 考虑一下大数问题（如：一个字符串太长了，某个字符串的次数大于了`Integer.MAX_VALUE`，就会产生问题，所以要进行判断）
  - 在Java中字符：`''`，字符串：`""`，注意区别
  - 常用代码api

```
//返回str字符串中索引为i的字符
str.charAt(i)
//将字符串转为字符数组
char[] chars = str.toCharArray();
//使用字符数组来构造字符串
String str = new String(chars);
```

### 哈希表

- **基本知识**
- **题目类型**
- **注意事项**

### 链表

- **基本知识**
  - 要用到节点的，先创建节点
  - 我发现指针可以解决关于链表的很多题目（单指针、双指针等）
    - 一般都是一个指针先走几步，然后另一个指针再开始走
    - 或者是指针走的速度不一样，一快一慢
- **题目类型**
  - 反转链表（如：`两个两个的反转`、`全部翻转`）
    - 预设节点 + 三个指针（或者递归）、三个指针、栈
  - 删除链表中的节点（时间复杂度`O(1)`：不一定非得知道前一个节点，知道后一个节点，然后复制即可）
  - 找公共节点（如：`两个链表中的第一个公共节点`）
  - 合并链表（如：`合并两个排序的链表`）
- **注意事项**
  - 单链表结构，要注意如果改变了当前节点的指针后，能不能找到这个节点的后一个节点与前一个节点？
    - 可以使用指针，保存前一个或者后一个
    - 或者是前后节点都需要保存
  - 双指针法
    - 两个指针，控制变量：速度相同？，谁先走几步？
  - 三指针法
    - 两个指针保存节点的前节点、后节点，加上节点本身的指针
  - 对于移动节点的问题（移动到**第**n个节点，特别是在删除**第**几个节点的题目中）
    - 可以预设一个节点，让其指向头节点，然后指针从这个节点开始移动，这样移动一次，就到了**第**一个节点处，移动n次就到了**第**n个节点处

```
//这样的好处是：移动一次就到了第一个节点，移动n次就到了第n个节点！！！移动次数与节点是序号是对应的
1->2->3->4
```

- 如果要创建一个新链表，并且要操作这个链表的话，需要在创建一个指针去操作，这样返回新节点的头部时，就可以直接返回新链表头部节点即可

```
ListNode preHead = new ListNode(-1);
//后续的操作在这个pre指针上进行
ListNode pre = preHead;
```

- 借助栈可以实现单链表从尾到头遍历节点

### 队列

- **基本知识**
  - 特点：`FIFO` 先进先出
  - java中的api
    - add、poll、peek

```
//使用向上转型
Queue<TreeNode> queue = new LinkedList<>();	
//双端队列（单调双向队列），方法都是addFirst、addLast之类的，注意是Deque，不是Dequeue！！！
Deque<Integer> deque = new LinkedList<Integer>();
//优先级队列，只有添加元素时会自动更新
//逆序排序，大小为12个元素
PriorityQueue<Integer> queue = new PriorityQueue<>(12, Comparator.reverseOrder());
//可以自己实现Comparator接口
PriorityQueue<Integer> queue = new PriorityQueue<>(12, new Comparator<Integer>() {
    @Override
    public int compare(Integer o1, Integer o2) {
        //正序排序
        return o1 - o2;
    }
});
```

- **题目类型**
  - **最大值**
    - 定义一个队列，实现max方法得到队列中的最大值。要求入列、出列以及取最大值的方法时间复杂度都是O(1)
      - 两个队列，一个存数据，一个存最大值
    - 滑动窗口（用双端队列来解决）
  - **队列的实现**
    - 可以使用两个栈来实现（一个进栈、一个出栈，注意出栈为空时，才进行转移元素）
    - 数组可以实现`循环双端队列`（两个指针：头、尾，一个容量），当然，循环队列也可以实现咯~
      - 通过 加上容量然后取余 的操作可以实现循环这个目标
      - 浪费一个位置，来避免队列为空与队列为慢的判别条件冲突（初始化时容量要+1）
      - 其中，头指针指向第一个元素，尾指针指向的是最后一个元素的下一个，这里在返回尾部元素时，要注意防止越界，使用+capacity取余的操作来返回
      - 如下：
        - 元素是否满了？`(tail + 1) % capacity`
        - 是否为空？`head == tail`
        - 插入头元素时，元素索引：`(head - 1 + capacity) % capacity`
        - 删除头元素时，元素索引：`(head + 1) % capacity`
        - 插入尾元素时，元素索引：`(tail + 1) % capacity`
        - 删除尾元素时，元素索引：`(tail - 1 + capacity) % capacity`
        - 返回尾元素：`return values[(tail - 1 + capacity) % capacity];`，这里防止数组越界
    - 单链表也可以实现（头指针、尾指针）
- **注意事项**
  - 操作元素的时，一定要判断队列是否为空

```
maxQueue.size() != 0 
//或者
deque.isEmpty()
// 当 tail 为 0 时防止数组越界
arr[(tail - 1 + capacity) % capacity];
```

### 栈

- **基本知识**
  - 先进后出
- **题目类型**
  - 实现一个栈（如：`包含 min 函数的栈`，`两个队列实现一个栈`）
  - 根据入栈、出栈序列判断是不是栈（如：`栈的压入、弹出序列`）
- **注意事项**

### 树

- **基本知识**
  - 一个树的节点：左指针、右指针、父节点指针、或者是子树指针集合
  - 前、中、后序遍历一定得会，层序遍历！
  - 树的深度必须会找（每个节点的子树的深度，都是右子树、左子树深度的最大值 + 1）
  - 二叉排序树（二叉查找树、二叉搜索树）：左、右子节点的值分别小于、大于父节点的值
    - 中序遍历序列为递增的（左根右）、或者递减的（右根左）
  - 平衡二叉树（平衡排序二叉树）：有二叉排序的特点，并且平衡因子 <= 1（即左右子树的高度差绝对值不超过1）
- **题目类型**
  - 在树的前序、中序、后序遍历序列中找一个节点的下一个节点
    - `二叉树中序遍历的下一个结点`：看是否有右子树，分情况
  - 树的深度
    - `输入一棵二叉树，求该树的深度`：一个节点的树的深度为左、右子树深度的最大值 + 1
    - `输入一棵二叉树，判断该二叉树是否是平衡二叉树`：根据左右子树的深度差是否大于1
  - 二叉搜索树
    - `二叉搜索树的第K大节点`：二叉搜索树的特点：中序遍历序列是排好序的（思维不要局限了，左->根->右、右->根->左）
- **注意事项**
  - 普通树的节点定义：使用 `List<Node> children` 来表示，然后遍历的话，使用foreach去递归调用即可

## 位运算

- **基本知识**
  - 与`&`
    - 在java中可以这样写：`a ^= i`
  - 异或`^`
    - 在java中可以这样写：`a ^= i`
  - 右移`>>`

```
a右移n位：a >> n
```

- 左移`<<`
- 两个数字进行异或，相同为0，不同为1

```
a ^ b
```

- 一个`int`32位，有时候会操作整数的位
- **找到第一个不同的位**
  - 选择1为基准数，因为1前面全是0，一个数字与1进行与操作就相当于这个数字的最低位在进行与操作

```
//找到第一个不同的位
private int getIndexOfFirstDiffBit(int result) {
    int index = 0;
    while (result != 0) {
        if ((result & 1) == 0)
            return index;
        result = result >> 1;
        index++;
    }
    return -1;
}
//可以通过对1的移动，来操作一个数字的指定位数
int mark = 1;
mark = mark << 1;//这样就将1移动了倒数第二个低位了
```

- **二进制转为十进制**

```
//二进制转为十进制
int value = 0;
for (int i = 31; i >= 0; i--) {
    value += bitSum[i] * Math.pow(2, 31 - i);
}
```

- **是否为偶数**

```
//偶数的最低位是0
(n & 1) == 0;
```

- **题目类型**
- **注意事项**



## 典型算法

### 排序

- **归并排序**
  - 可以在分组的时候做文章，比如：`数组中的逆序对`
- **快速排序**
  - 可以不用全部排完，因为每一次的排序都将小的数、大的数分割了的，比如：`最小的k个数`
- 冒泡排序
  - 从后往前，通过与相邻元素的比较和交换来把小的数交换到最前面
  - O(n ^ 2)
- 选择排序
  - 简单选择排序：每次排序将最小的值放到前面
    - O(n ^ 2)
  - 堆排序
  - https://www.cnblogs.com/wxisme/p/5243631.html

### 查找

- 查找算法合集

### 其他

- **动态规划**
  - 剑指offer：FortyTwo第二种解法
- **深度优先搜索**
- **回溯算法**
  - 在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回上一步，尝试别的路径
- **分治算法**
  - 对一个规模为n的问题，能直接解决就解决；如果比较复杂直接解决不了，则将其分解为k个规模较小的子问题（子问题相互独立、形式与原问题相同），递归这些子问题，然后合并记得到原问题的解
  - 一般使用递归来实现
  - k = 2，二分法（二分查找、归并排序等）
- **贪心算法**
  - 解决最优解问题，从局部最优解到整体最优解（找到一个最优解，然后一直用这个最优解，最终得到整体的最优解）

### 实现方式

- **递归**
  - **其实就是找每次操作相同的步骤，使用一个方法来实现，然后就可以在方法中的某个与下一次操作有关的步骤中，调用本身方法来返回下一次操作**
    - 如：`两个两个的反转链表`。每次操作的都是两个节点：可以发现每次`反转、连接`这两个操作与后面的`反转、连接`的两个操作是类似的：都是将第二个节点变为了头节点并与之前的头节点连接，头节点变为了第二个节点并去连接后面反转的节点
      - 所以，递归代码如下：

```
//两个两个的反转链表，递归实现
class Solution {
    public ListNode swapPairs(ListNode head) {
        if (head == null || head.next == null)
            return head;
        //第二个节点变为头节点1
        ListNode newHead = head.next;
        //头节点去连接后面反转的节点
        head.next = swapPairs(newHead.next);
        //与原来的头节点进行连接
        newHead.next = head;
        return newHead;   
    }
}
```

- **循环迭代**
  - **就是通过指针 + 循环的方式来实现**
    - 关键就是找规律 + 临界值的判断

```
//两个两个的反转链表，迭代实现
class Solution {
    public ListNode swapPairs(ListNode head) {
        if (head == null || head.next == null)
            return head;
        ListNode preNode = new ListNode();
        preNode.next = head;
        ListNode temp = preNode;
        while (temp.next != null && temp.next.next != null) {
            ListNode cur1 = temp.next;
            ListNode cur2 = temp.next.next;
            temp.next = cur2;
            cur1.next = cur2.next;
            cur2.next = cur1;
            temp = cur1;
        }
        return preNode.next;
    }
}
```

## 典型问题

- 极大极小问题
- 数学问题，多刷几道，每次记录
- 求树中两个节点的最低公共祖先
  - 是否是二叉树？是否是二叉搜索树？
  - 是否有父指针？
    - 转换为求两个链表中的第一个公共节点问题

## 智力题

- 记录智力题

## 注意点

- 非法输入、边界值的考虑    
  - 对于非法输入的返回值来说，要区分特殊情况的返回值（如：非法输入返回0，特殊情况也有返回0的）
  - 可以使用一个全局变量来解决，这样调用方法的时候，可以去拿到这个全局变量，然后做出决定
  - 是否溢出？
- `char` 与 `int` 型不能直接做四则运算，应该先用 `char` 值去减 `'0'`，然后得到的值，才能去和 `int` 做四则运算
- 注意单词拼写！！！如：`return`、`false`、`true`
- 调用方法的时候，别忘了括号！！！如： `isEmpty()`
- 递归消耗栈空间，要算在空间复杂度里，一个栈帧算一个
- 空指针问题，特别是链表、树的指针移动！！！
- 对临界值进行处理，鲁棒性的处理
- 使用位运算代替四则运算

```
a右移一位：a >> 1 <--> a / 2
a左移一位：a << 1 <--> a * 2
```

- 递归的时候，主要参数的类型，考虑java值传递的问题，得是引用类型或者数组类型