package other;

/**
 * 《剑指Offer》第二版，面试题 43: 1~n整数中1出现的次数
 *
 *      输入一个整数n，求1~n这n个整数的十进制表示中1出现的次数，例如输入12, 1~12中出现1的有1、10、11、12共5次
 *
 * 较好的解法：
 *      1. 比较直接的解法，写一个方式求一个整数中1出现的次数，然后循环调用即可
 *          a. 时间复杂度为O(nlogn)
 *      2. 暴比较力的方式，使用StringBuilder将1~n的所有数字拼接起来，然后一个个的数
 *          a. 时间复杂度居然为O(n)
 *      3. 非常精简的解法，找规律：
 *          a. 1可以出现在任意一位，比如3245，1出现在个、十、百、千位都可以。只要固定某一位为1，计算出该位是1的所有情况，
 *          将固定每一位得到的情况数相加就是最终结果。
 *          b. 要固定某一位为1，可以使用m = 1, 10, 100, 1000....，对n作除、余操作，将输入整数分为高位和低位两部分。
 *          举个例子，对于输入n = 3101592，m = 100，如果令a = n / m, b = n % m，将得到a = 31015，b= 92两部分，
 *          现在固定百位为1（始终固定a的最低位），即`xxxx1xx`这样的形式，这样形式的数有多少个呢？
 *
 * ```
 * 0000 1 00
 * 0000 1 01
 * .....
 * 0000 1 99
 * 0001 1 00
 * ......
 * 0001 1 99
 * 0002 1 00
 * ......
 * 0002 1 99
 * ......
 * 3101 1 00
 * ......
 * 3101 1 99
 * ```
 *
 * 为了看得直观，上面刻意将数字从百位处分隔开，对于百位之前的高位数，总共有`0000~3101`共3102种情况，而每一种情况对应着低位有`00~99`共100种情况，因此百位为1的情况数是3102*100，也就是`(a / 10 + 1) * m`种情况。好，现在得到百位为1的情况数了，个位与千位等其他位计算方法和上面类似，只需取不同的m就能将输入的整数分成两部分并固定某一位为1.
 *
 * 接下来m = 1000时，3101592被分成a = 3101和b = 592两部分，现在固定千位为1，但是此时千位本来就是1了，来看和上面有什么不同
 *
 * ```
 * 000 1 000
 * ......
 * 000 1 999
 * 309 1 000
 * ......
 * 309 1 999
 * 310 1 000
 * ......
 * 310 1 592
 * ```
 *
 * 可以看到千位前的高位从`000~309`和上面一样，每一种情况都有`000~999`种可能，但是到310时，后面最多只能到592，共`000~592`是593种情况。此时千位为1的情况总数为：310 * 1000 + 593，即**当前要被固定的位在输入中本来就是1**的话有`(a / 10) * m + b + 1`种情况。
 *
 * 再看m = 10000，固定万位的情况。a = 310, b = 1592.
 *
 * ```
 * 00 1 0000
 * ......
 * 00 1 9999
 * 30 1 0000
 * ......
 * 30 1 9999
 * ```
 *
 * 没有了，共31 * 10000种，即**当前要被固定的位在输入中是0**的话有`(a / 10) * m`种情况。
 *
 * 一开始固定百位其实就是**当前要被固定的位在输入中是2~9**这种情况。
 *
 * 分析得差不多了，现在考虑这三种情况计算就好了。
 */
public class FortyThree {
    public static void main(String[] args) {
        System.out.println(numOfOne(12));
        System.out.println(numOfOneBySB(12));
        System.out.println(numOfOneByRuler(12));
    }

    /**
     * 第一种，求出通用解法，然后循环的方式
     * @param num
     * @return
     */
    private static int numOfOne(int num) {
        //负数转为正数即可
        if (num < 0) num = Math.abs(num);
        int count = 0;
        for (int i = 1; i <= num; i++) {
            count += number(i);
        }
        return count;
    }

    private static int number(int num) {
        int count = 0;
        while (num != 0) {
            if (num % 10 == 1) count++;
            num /= 10;
        }
        return count;
    }

    /**
     * 第二种，使用StringBuilder暴力的求出1的个数
     * @param num
     * @return
     */
    private static int numOfOneBySB(int num) {
        //将负数转为正数
        if (num < 0) num = Math.abs(num);
        StringBuilder sb = new StringBuilder();
        for (int i = 1; i <= num; i++) {
            sb.append(i);
        }
        int count = 0;
        for (int i = 0; i < sb.length(); i++) {
            if (sb.charAt(i) == '1')
                count++;
        }
        return count;
    }

    /**
     * 第三种，固定某一位为1，计算出该位是1的所有情况，将每一位固定得到的情况数相加就是最终结果
     * 将整数分为a、b两部分，按照固定位来分：如：3101592，固定百位为1，a = 31015, b = 92
     * 1. 当前要被固定为1的位原来是0：(a/10)*m
     * 2. 当前要被固定为1的位原来是1：(a/10)*m + b + 1
     * 3. 当前要被固定为1的位原来是2~9：(a/10 + 1)*m
     * @param num
     * @return
     */
    private static int numOfOneByRuler(int num) {
        //将负数转为正数
        if (num < 0) num = Math.abs(num);
        int count = 0;
        for (int i = 1; i <= num; i *= 10) {
            int a = num / i;
            int b = num % i;
            if (a % 10 == 0) count += (a / 10) * i;
            else if (a % 10 == 1) count += (a / 10) * i + b + 1;
            else count += (a / 10 + 1) * i;
        }
        return count;
    }
}
